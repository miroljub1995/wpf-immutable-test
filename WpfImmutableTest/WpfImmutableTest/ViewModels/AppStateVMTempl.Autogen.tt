<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="netstandard" #>
<#@ assembly name="$(TargetPath)" #>
<#@ assembly name="$(TargetDir)\\System.Collections.Immutable.dll" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Collections.Immutable" #>
<#@ output extension=".cs" #>
//this is autogenerated file, do not modify it
<#
	var type = typeof(WpfImmutableTest.Store.AppState);
	var mappings = GetTypesMappingsTypeO(type.Assembly);
	var dictInverse = mappings.ToDictionary((i) => i.Value, (i) => i.Key);

	var typeO = dictInverse.Where(t => t.Value.FullName == type.FullName).First().Value;
	var typeVM = dictInverse[typeO];

	List<Class> classes = new List<Class>();
	var exType = CreateExtendedTypeO(typeVM, mappings, classes);
#>
<#+
	public class TypeO 
	{
		public string Name;
		public string Namespace;
		public List<TypeO> GenArgs = new List<TypeO>();
		public string FullName => Namespace + '.' + Name;
		public bool IsGeneric => GenArgs.Count > 0; 
	}
	public class Class : TypeO 
	{
		public List<Field> Fields = new List<Field>();
		public List<Prop> Props = new List<Prop>();
	}
	public class Field 
	{
		public TypeO Type;
		public string Name;
	}
	public class Prop : Field 
	{
		public string NameOfFieldToGet;
	}

	public TypeO GetTypeO(Type type)
	{
		if(type.IsGenericType)
		{
			return new TypeO
			{
				Name = type.GetGenericTypeDefinition().Name.Split('`')[0],
				Namespace = type.GetGenericTypeDefinition().Namespace,
				GenArgs = type.GetGenericArguments().Select(t=>GetTypeO(t)).ToList()
			};
		}
		return new TypeO
		{
			Name = type.Name,
			Namespace = type.Namespace
		};
	}

	public Dictionary<Class, Class> GetTypesMappingsTypeO(System.Reflection.Assembly assembly)
    {
        var mappings = new Dictionary<Class, Class>();
        foreach (Type type in assembly.GetTypes())
        {
            var attrs = type.GetCustomAttributes(typeof(WpfImmutableTest.ViewModels.ExtendFromImmutableWithTemplAttribute), true);
            if (attrs.Length == 1)
            {
                var attr = (WpfImmutableTest.ViewModels.ExtendFromImmutableWithTemplAttribute) attrs[0];
                //mappings[type] = attr.Type;
				var vmType = new Class{Name = type.Name, Namespace = type.Namespace};
				var immType = new Class{Name = attr.Type.Name, 
										Namespace = attr.Type.Namespace, 
										Props = attr.Type.GetProperties().Where(p => p.CanRead).Select(p => new Prop{Name = p.Name, Type = GetTypeO(p.PropertyType)}).ToList()};
				
				mappings[vmType] = immType;
            }
        }
        return mappings;
    }

	public TypeO CreateExtendedTypeO(TypeO type, Dictionary<TypeO, TypeO> mappings, List<Class> classes)
    {
        var dictInverse = mappings.ToDictionary((i) => i.Value, (i) => i.Key);
        if (!mappings.ContainsKey(type) && !dictInverse.ContainsKey(type))
        {
            return type;//return new TypeO{Name = type.Name, Namespace = type.Namespace};
        }
		
        Class exType;
		if (dictInverse.ContainsKey(type))
        {
            var tmp = type;
            exType = (Class)type;
            type = dictInverse[tmp];
        }
        else
        {
            exType = (Class)mappings[type];
        }


        var typeName = type.Name;
		var typeNamespace = type.Namespace;

		//fields and props
		var newProps = new List<Prop>();
		var newFields = new List<Field>();
		
		Class newClassType = new Class
		{
			Name = typeName,
			Namespace = typeNamespace
		};
		classes.Add(newClassType);

        var props = exType.Props;
        foreach(var prop in props)
        {
            var propType = prop.Type;
            var fieldName = "_" + prop.Name.First().ToString().ToLower() + prop.Name.Substring(1);
            TypeO fieldType;
            if (propType.IsGeneric && propType.Name == "ImmutableList")
            {
                //create observable list field and name it line propType
				fieldType = new TypeO{Name = "ObservableCollection",
									  Namespace = "System.Collections.ObjectModel"};
				fieldType.GenArgs.Add(CreateExtendedTypeO(propType.GenArgs[0], mappings, classes));
            }
            else if (dictInverse.ContainsKey(propType))
            {
				fieldType = CreateExtendedTypeO(propType, mappings, classes);
            }
			else
			{
				fieldType = propType;
			}

            //add field
			newClassType.Fields.Add(new Field
			{
				Name = fieldName,
				Type = fieldType
			});

            //add property
			newClassType.Props.Add(new Prop
			{
				Name = prop.Name,
				Type = fieldType,
				NameOfFieldToGet = fieldName
			});
            
        }
		return newClassType;
    }
#>